# PYTHON IS A ZERO-INDEXED LANGUAGE!!! (unlike R, which is one-indexed)

# type() function gives you type of data used as an argument, e.g. integer, float, string
# IF statements: 
if condition:
    # code here
elif condition: # the same as else if in R
    # code here
else:
    # code here

# FOR LOOPS
# Syntax for for loops:
for element in list: # ALWAYS put a colon at the end of for statement! Similar as in IF statement
    # do something

# when checking e.g. type of a variable, i don't put the desired type in between quotation marks, see below:
if type(x) == float: # (instead of if type(x) == "float")
    # do sth

# FORMAT SPECIFIERS
# when i want to fill placeholders in my text with the value of my variables, i use the following syntax:
"There are %d items in the suitcase." % (list_length)
# %d is a placeholder (could be one or more of them), then % comes, and placeholders are replaced accordingly with
# values of variables given in parentheses after %. These are so called format specifiers: %s is for character string,
# %d is for integer and %f is for float.

# LISTS
# I can create lists by putting items between square brackets:
new_list = [15, True, "goldfish", False, 56.7, "sloth"]
# when i want to access particular elements of a list, i use an index, i.e. numbers in square brackets, as below:
first_two = new_list[0:2]
# NB: We start at the index before the colon and continue up to BUT NOT INCLUDING the index after the colon.
# TOGETHER WITH ZERO INDEXING, THIS IS CRAZY SHIT :) and it may cause some problems for newbie programmers like me.
last_two = new_list[4:6] 
# here i have 6 after the colon. There is no 6th element in the list (last is 5th - remember 0 indexing), but i have to use 
# len(new_list) + 1 if i want to access the last element of the list. Crazy Crazy Crazy.

# DICTIONARIES
# A dictionary is similar to a list, but i'm accessing a value by a key, not by an index. Dictionaries
# are enclosed in curly braces. Keys are strings so they are enclosed in quotation marks. See below for syntax:
residents = {'Puffin' : 104, 'Sloth' : 105, 'Burmese Python' : 106}
print residents['Puffin'] 
# Useful when i don't know the place of my value in a string or in a list, but i know the name of a key.
dictionary = {} # creates an empty dictionary
dictionary_name[new_key] = new_value # adds new item to the dictionary
dictionary_name[existing_key] = new_value # changes the value assigned to the existing key
# Since a value assigned to a key could be a list, i.e. a list nested in a list-like dictionary, if i want to access
# a specific element of that nested list, the syntax goes like this:
inventory = {
    'gold' : 500,
    'pouch' : ['flint', 'twine', 'gemstone'], 
    'backpack' : ['xylophone','dagger', 'bedroll'] # NB: we use a colon to separate key form value, not an equal sign
}
second_element = inventory[pouch][1]
# NB: square brackets above are not nested within one another, like it would be in R. The brackets for key are 
# the first pair and they are closed before i open another pair to tell Python which element of the list i want to access.
# Tiny thing, but i can feel this could be freaking important later on :)

# if i create two dictionaries with the same keys, i can access values from both of them in the same IF or FOR statement:
prices = {
    "banana" : 4,
    "apple"  : 2,
    "orange" : 1.5,
    "pear"   : 3,
}
stock = {
    "banana" : 6,
    "apple"  : 0,
    "orange" : 32,
    "pear"   : 15,
}
for key in prices:
    print key
    print "price: " + str(prices[key])
    print "stock: " + str(stock[key])

# INSTALLING MODULES
# When i want to use a new module preinstalled in Python, e.g. math module, i have to import it first.
# This is called generic import.
import math
# when i've done this, in order to use sqrt() i need to use the following syntax:
number = 64
print math.sqrt(number)
# if i want to use just one or a few particular variables or functions from that module, i can import just them
from math import sqrt
# then, the syntax goes like this:
sqrt(number)
# if i want to import all module elements but at the same time i don't want to repeat math. prefix all the time,
# i just need to perform so called universal import, and the syntax is:
from math import *
# Although the last option looks most convenient, it ain't so. For example, it loads your RAM with many variables
# and functions you probably won't use. Moreover, Python may get confused when it comes to distinguishing between 
# functions with the same name but coming from different modules. The safest way is either to perform generic import
# and use module. prefix, or to import specific variables/functions.
# There are, of course, many functions that are ready to use, no import needed.

# DEFINING FUNCTIONS
# The syntax for defining functions:
def function(arg1, arg2, ...):
    # code function's tasks here

# WORKING WITH STRINGS
# four basic functions useful when working with strings:
string = "monty_python"
string2 = 21345
len(string) # gives you the length of a given string
str(string2) # changes a given variable into string
string.upper() # changes all characters of a string into upper case
string.lower() # as above, lower case
# NB: len() and str() are used in an R-similar way - function(x)
# upper() and lower() need to be prefixed with a variable name ended with a dot, like in the example above

# MATHEMATICAL OPERATIONS - DIVISION
# another strange and totally non-intuitive thing - types of data in division.
# say i want to divide 5 by 2. In the normal world the result is just 2.5, with no overthinking. BUT NOT HERE!
# if i want to divide integer by integer and the result is a float, the result i get in Python would nevertheless be
# integer, additionally rounded down. WTF. if i want to divide a float by an integer, the result is a float - ok, i can
# agree with that one. BUT, if i want to divide an integer by an integer and get a float, i need to use float() to change
# of the integers' type into float. 5 divided by 2 is 2 by default? Python, seriously? Now i'm starting to understand
# why only ultrageeks get Python jobs :)
